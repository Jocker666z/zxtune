/*
 * Native libs basic functionality
 *
 */

def getListProperty(name, defvalue) {
  def prop = localProperties.getProperty(name, defvalue)
  return prop.split();
}

android {
    def code = defaultConfig.versionCode
    def name = defaultConfig.versionName

    flavorDimensions "abi"

    productFlavors {
        fat {
            dimension "abi"
            versionCode code + 0
            versionName name + ""
            ndkConfig.abiFilters getListProperty("flavors.fat.abifilters", "armeabi armeabi-v7a")
        }

        arm7 {
            dimension "abi"
            versionCode code + 2
            versionName name + "+2_armeabi-v7a"
            ndkConfig.abiFilters "armeabi-v7a"
        }

        arm64 {
            dimension "abi"
            versionCode code + 3
            versionName name + "+3_arm64-v8a"
            ndkConfig.abiFilters "arm64-v8a"
        }

        x86 {
            dimension "abi"
            versionCode code + 4
            versionName name + "+4_x86"
            ndkConfig.abiFilters "x86"
        }

        x86_64 {
            dimension "abi"
            versionCode code + 5
            versionName name + "+5_x86_64"
            ndkConfig.abiFilters "x86_64"
        }
    }

    def flavorsFilter = getListProperty("flavors.abi", "fat")
    variantFilter { variant ->
        def flavor = variant.getFlavors().get(0)
        if (!flavorsFilter.contains(flavor.name)) {
            println "Disable flavor " + flavor.name
            variant.setIgnore(true)
        }
    }
}

def callMake(cmdline) {
    def fullCmd = "make platform=android ${cmdline}"
    def proc = fullCmd.execute()
    proc.consumeProcessOutput(System.out, System.out)
    assert 0 == proc.waitFor()
}

android {
    applicationVariants.all { variant ->
        tasks.getByName("compile${variant.name.capitalize()}Ndk").enabled = false
        def taskName = "nativeLibs${variant.name.capitalize()}"
        task(taskName) {
            def libsDir = variant.ndkCompile.soFolder
            //optimize incremental builds - assume existing soFolder means that all libs are ready
            outputs.dir libsDir
            doLast {
                def cpuCount = Runtime.runtime.availableProcessors()
                def jniDir = variant.ndkCompile.source.first().parent
                variant.ndkCompile.abiFilters.each { arch ->
                    def baseCmd = "arch=${arch} -C ${jniDir}"
                    callMake("${baseCmd} -j ${cpuCount}")
                    def dstDir = file("${libsDir}/${arch}")
                    dstDir.mkdirs()
                    callMake("${baseCmd} DESTDIR=${dstDir} install")
                }
            }
        }
        tasks.getByName("package${variant.name.capitalize()}").dependsOn.add(taskName)
    }
}

android {
    applicationVariants.all { variant ->
        def taskName = "nativeLibsDebugSymbols${variant.name.capitalize()}"
        task(taskName) {
            def objsDir = variant.ndkCompile.objFolder
            //optimize incremental builds - assume existing objFolder means that all libs are ready
            outputs.dir objsDir
            doLast {
                def jniDir = variant.ndkCompile.source.first().parent
                variant.ndkCompile.abiFilters.each { arch ->
                    def baseCmd = "arch=${arch} -C ${jniDir}"
                    def objDir = file("${objsDir}/${arch}")
                    objDir.mkdirs()
                    callMake("${baseCmd} DESTDIR=${objDir} install_debug")
                }
            }
        }
    }
}

def getUsedArchitectures() {
    def result = new HashSet<String>()
    android.applicationVariants.all { variant ->
        result.addAll(variant.ndkCompile.abiFilters)
    }
    return result
}

android {
    ext.publicBuildsDir = "${treeRoot}/Builds/${defaultConfig.versionName}/android"
    
    task publicBuild

    applicationVariants.all { variant ->
        def suffix = variant.name.capitalize()
        def baseName = "${project.name}_${variant.mergedFlavor.versionName}"
        def publishApk = task("publishApk${suffix}", type: Copy) {
            def apks = variant.outputs
            assert apks.size() == 1
            from apks.first().outputFile
            into publicBuildsDir
            rename ".*", "${baseName}.apk"
        }

        if (variant.getBuildType().isMinifyEnabled()) {
            publishApk.doLast {
                copy {
                    from variant.mappingFile
                    into publicBuildsDir
                    rename ".*", "${baseName}-mapping.txt"
                }
            }
        }
    
        if (variant.buildType.name == "release") {
            def taskName = "publicBuild${variant.flavorName.capitalize()}"
            task(taskName, dependsOn: ["assemble${suffix}", "publishApk${suffix}"]) {
            }
            publicBuild.dependsOn.add(taskName)
        }
    }

    task publishPdb {
        def dbgArchive = "${publicBuildsDir}/${project.name}.tar.bz2"
        outputs.file dbgArchive
        doLast {
            def dbgDir = "${publicBuildsDir}/debug"
            def jniDir = sourceSets.findByName("main").jni.srcDirs.first()
            getUsedArchitectures().each { arch ->
                def pdbDir = file("${dbgDir}/${arch}")
                pdbDir.mkdirs()
                callMake("arch=${arch} -C ${jniDir} DESTDIR=${pdbDir} install_debug")
            }
            "tar -cjf ${dbgArchive} --remove-files ${dbgDir}".execute().waitFor()
        }
    }

    publicBuild.dependsOn.add(publishPdb)
}
